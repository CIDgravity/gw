// Code generated by github.com/whyrusleeping/cbor-gen. DO NOT EDIT.

package carlog

import (
	"fmt"
	"io"
	"math"
	"sort"

	cid "github.com/ipfs/go-cid"
	cbg "github.com/whyrusleeping/cbor-gen"
	xerrors "golang.org/x/xerrors"
)

var _ = xerrors.Errorf
var _ = cid.Undef
var _ = math.E
var _ = sort.Sort

func (t *Head) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write([]byte{170}); err != nil {
		return err
	}

	// t.Valid (bool) (bool)
	if len("Valid") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Valid\" was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("Valid"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Valid")); err != nil {
		return err
	}

	if err := cbg.WriteBool(w, t.Valid); err != nil {
		return err
	}

	// t.DataEnd (int64) (int64)
	if len("DataEnd") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"DataEnd\" was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("DataEnd"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("DataEnd")); err != nil {
		return err
	}

	if t.DataEnd >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.DataEnd)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.DataEnd-1)); err != nil {
			return err
		}
	}

	// t.Version (int64) (int64)
	if len("Version") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Version\" was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("Version"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Version")); err != nil {
		return err
	}

	if t.Version >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Version)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.Version-1)); err != nil {
			return err
		}
	}

	// t.External (bool) (bool)
	if len("External") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"External\" was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("External"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("External")); err != nil {
		return err
	}

	if err := cbg.WriteBool(w, t.External); err != nil {
		return err
	}

	// t.ReadOnly (bool) (bool)
	if len("ReadOnly") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"ReadOnly\" was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("ReadOnly"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("ReadOnly")); err != nil {
		return err
	}

	if err := cbg.WriteBool(w, t.ReadOnly); err != nil {
		return err
	}

	// t.DataStart (int64) (int64)
	if len("DataStart") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"DataStart\" was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("DataStart"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("DataStart")); err != nil {
		return err
	}

	if t.DataStart >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.DataStart)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.DataStart-1)); err != nil {
			return err
		}
	}

	// t.Finalized (bool) (bool)
	if len("Finalized") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Finalized\" was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("Finalized"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Finalized")); err != nil {
		return err
	}

	if err := cbg.WriteBool(w, t.Finalized); err != nil {
		return err
	}

	// t.Offloaded (bool) (bool)
	if len("Offloaded") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Offloaded\" was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("Offloaded"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Offloaded")); err != nil {
		return err
	}

	if err := cbg.WriteBool(w, t.Offloaded); err != nil {
		return err
	}

	// t.RetiredAt (int64) (int64)
	if len("RetiredAt") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"RetiredAt\" was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("RetiredAt"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("RetiredAt")); err != nil {
		return err
	}

	if t.RetiredAt >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.RetiredAt)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.RetiredAt-1)); err != nil {
			return err
		}
	}

	// t.LayerOffsets ([]int64) (slice)
	if len("LayerOffsets") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"LayerOffsets\" was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len("LayerOffsets"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("LayerOffsets")); err != nil {
		return err
	}

	if len(t.LayerOffsets) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.LayerOffsets was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.LayerOffsets))); err != nil {
		return err
	}
	for _, v := range t.LayerOffsets {
		if v >= 0 {
			if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(v)); err != nil {
				return err
			}
		} else {
			if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-v-1)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (t *Head) UnmarshalCBOR(r io.Reader) (err error) {
	*t = Head{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajMap {
		return fmt.Errorf("cbor input should be of type map")
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("Head: map struct too large (%d)", extra)
	}

	var name string
	n := extra

	for i := uint64(0); i < n; i++ {

		{
			sval, err := cbg.ReadString(cr)
			if err != nil {
				return err
			}

			name = string(sval)
		}

		switch name {
		// t.Valid (bool) (bool)
		case "Valid":

			maj, extra, err = cr.ReadHeader()
			if err != nil {
				return err
			}
			if maj != cbg.MajOther {
				return fmt.Errorf("booleans must be major type 7")
			}
			switch extra {
			case 20:
				t.Valid = false
			case 21:
				t.Valid = true
			default:
				return fmt.Errorf("booleans are either major type 7, value 20 or 21 (got %d)", extra)
			}
			// t.DataEnd (int64) (int64)
		case "DataEnd":
			{
				maj, extra, err := cr.ReadHeader()
				var extraI int64
				if err != nil {
					return err
				}
				switch maj {
				case cbg.MajUnsignedInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 positive overflow")
					}
				case cbg.MajNegativeInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 negative overflow")
					}
					extraI = -1 - extraI
				default:
					return fmt.Errorf("wrong type for int64 field: %d", maj)
				}

				t.DataEnd = int64(extraI)
			}
			// t.Version (int64) (int64)
		case "Version":
			{
				maj, extra, err := cr.ReadHeader()
				var extraI int64
				if err != nil {
					return err
				}
				switch maj {
				case cbg.MajUnsignedInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 positive overflow")
					}
				case cbg.MajNegativeInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 negative overflow")
					}
					extraI = -1 - extraI
				default:
					return fmt.Errorf("wrong type for int64 field: %d", maj)
				}

				t.Version = int64(extraI)
			}
			// t.External (bool) (bool)
		case "External":

			maj, extra, err = cr.ReadHeader()
			if err != nil {
				return err
			}
			if maj != cbg.MajOther {
				return fmt.Errorf("booleans must be major type 7")
			}
			switch extra {
			case 20:
				t.External = false
			case 21:
				t.External = true
			default:
				return fmt.Errorf("booleans are either major type 7, value 20 or 21 (got %d)", extra)
			}
			// t.ReadOnly (bool) (bool)
		case "ReadOnly":

			maj, extra, err = cr.ReadHeader()
			if err != nil {
				return err
			}
			if maj != cbg.MajOther {
				return fmt.Errorf("booleans must be major type 7")
			}
			switch extra {
			case 20:
				t.ReadOnly = false
			case 21:
				t.ReadOnly = true
			default:
				return fmt.Errorf("booleans are either major type 7, value 20 or 21 (got %d)", extra)
			}
			// t.DataStart (int64) (int64)
		case "DataStart":
			{
				maj, extra, err := cr.ReadHeader()
				var extraI int64
				if err != nil {
					return err
				}
				switch maj {
				case cbg.MajUnsignedInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 positive overflow")
					}
				case cbg.MajNegativeInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 negative overflow")
					}
					extraI = -1 - extraI
				default:
					return fmt.Errorf("wrong type for int64 field: %d", maj)
				}

				t.DataStart = int64(extraI)
			}
			// t.Finalized (bool) (bool)
		case "Finalized":

			maj, extra, err = cr.ReadHeader()
			if err != nil {
				return err
			}
			if maj != cbg.MajOther {
				return fmt.Errorf("booleans must be major type 7")
			}
			switch extra {
			case 20:
				t.Finalized = false
			case 21:
				t.Finalized = true
			default:
				return fmt.Errorf("booleans are either major type 7, value 20 or 21 (got %d)", extra)
			}
			// t.Offloaded (bool) (bool)
		case "Offloaded":

			maj, extra, err = cr.ReadHeader()
			if err != nil {
				return err
			}
			if maj != cbg.MajOther {
				return fmt.Errorf("booleans must be major type 7")
			}
			switch extra {
			case 20:
				t.Offloaded = false
			case 21:
				t.Offloaded = true
			default:
				return fmt.Errorf("booleans are either major type 7, value 20 or 21 (got %d)", extra)
			}
			// t.RetiredAt (int64) (int64)
		case "RetiredAt":
			{
				maj, extra, err := cr.ReadHeader()
				var extraI int64
				if err != nil {
					return err
				}
				switch maj {
				case cbg.MajUnsignedInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 positive overflow")
					}
				case cbg.MajNegativeInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 negative overflow")
					}
					extraI = -1 - extraI
				default:
					return fmt.Errorf("wrong type for int64 field: %d", maj)
				}

				t.RetiredAt = int64(extraI)
			}
			// t.LayerOffsets ([]int64) (slice)
		case "LayerOffsets":

			maj, extra, err = cr.ReadHeader()
			if err != nil {
				return err
			}

			if extra > cbg.MaxLength {
				return fmt.Errorf("t.LayerOffsets: array too large (%d)", extra)
			}

			if maj != cbg.MajArray {
				return fmt.Errorf("expected cbor array")
			}

			if extra > 0 {
				t.LayerOffsets = make([]int64, extra)
			}

			for i := 0; i < int(extra); i++ {
				{
					maj, extra, err := cr.ReadHeader()
					var extraI int64
					if err != nil {
						return err
					}
					switch maj {
					case cbg.MajUnsignedInt:
						extraI = int64(extra)
						if extraI < 0 {
							return fmt.Errorf("int64 positive overflow")
						}
					case cbg.MajNegativeInt:
						extraI = int64(extra)
						if extraI < 0 {
							return fmt.Errorf("int64 negative overflow")
						}
						extraI = -1 - extraI
					default:
						return fmt.Errorf("wrong type for int64 field: %d", maj)
					}

					t.LayerOffsets[i] = int64(extraI)
				}
			}

		default:
			// Field doesn't exist on this type, so ignore it
			cbg.ScanForLinks(r, func(cid.Cid) {})
		}
	}

	return nil
}
