package main

import (
	"bufio"
	"context"
	"encoding/hex"
	"errors"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"sort"
	"strings"
	"time"

	"github.com/charmbracelet/huh"
	"github.com/fatih/color"
	"github.com/filecoin-project/lotus/api"
	"github.com/google/uuid"
	"github.com/joho/godotenv"
	"github.com/lotus-web3/ribs/configuration"
	"github.com/lotus-web3/ribs/rbdeal"
)

const defaultEnvFile = "settings.env"

var (
	cidgHexChallengeRe = regexp.MustCompile(`^[a-f0-9]+$`)
	cidgLotusSignRe    = regexp.MustCompile(`^lotus wallet sign f1[a-z0-9]+ [a-f0-9]+$`)
	cidgApiKeyRe       = regexp.MustCompile(`^f0[a-z0-9]+-[A-Za-z0-9_\-]+$`)
)

// ---------------------- meta‑data helpers ------------------------------- //

type groupedEnvKey struct {
	Var          string
	DefaultValue string
	Section      string
	Advanced     bool
}

func collectKeys() ([]groupedEnvKey, error) {
	var keys []groupedEnvKey
	cfgT := reflect.TypeOf(configuration.Config{})

	sectionFor := func(env string) (section string, advanced bool) {
		switch {
		case strings.HasPrefix(env, "EXTERNAL_S3_"):
			return "S3", false
		case strings.HasPrefix(env, "EXTERNAL_LOCALWEB_"):
			return "LocalWeb", false
		case strings.HasPrefix(env, "CIDGRAVITY_"):
			return "CIDGravity", false
		case strings.HasPrefix(env, "RIBS_WALLET_"):
			return "Wallet", false
		case env == "RIBS_DEAL_CAN_SEND_COMMAND" || env == "RIBS_DEAL_CHECK_INTERVAL":
			return "Deals Advanced", true
		case strings.HasPrefix(env, "RIBS_DEAL_"):
			return "Deals", false
		case strings.HasPrefix(env, "RIBS_"):
			return "RIBS", true
		default:
			return "Misc", true
		}
	}

	var walk func(reflect.Type)
	walk = func(t reflect.Type) {
		for i := 0; i < t.NumField(); i++ {
			f := t.Field(i)
			if f.Anonymous {
				ft := f.Type
				if ft.Kind() == reflect.Ptr && ft.Elem().Kind() == reflect.Struct {
					walk(ft.Elem())
				} else if ft.Kind() == reflect.Struct {
					walk(ft)
				}
				continue
			}
			if f.Type.Kind() == reflect.Struct {
				walk(f.Type)
				continue
			}
			envTag := f.Tag.Get("envconfig")
			if envTag == "" {
				continue
			}
			def := f.Tag.Get("default")
			sec, adv := sectionFor(envTag)
			keys = append(keys, groupedEnvKey{Var: envTag, DefaultValue: def, Section: sec, Advanced: adv})
		}
	}
	walk(cfgT)
	sort.Slice(keys, func(i, j int) bool { return keys[i].Var < keys[j].Var })
	return keys, nil
}

// ------------------- env helpers ---------------------------------------- //

type EnvCommentFunc func(key string) string

func loadEnv(path string) (map[string]string, error) {
	m, err := godotenv.Read(path)
	if errors.Is(err, os.ErrNotExist) {
		return map[string]string{}, nil
	}
	return m, err
}

func saveEnv(path string, m map[string]string, commentFn EnvCommentFunc) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	w := bufio.NewWriter(f)
	fmt.Fprintln(w, "# Generated by gwcfg on", time.Now().Format(time.RFC3339))

	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		if comment := commentFn(k); comment != "" {
			for _, line := range strings.Split(comment, "\n") {
				fmt.Fprintf(w, "# %s\n", line)
			}
		}
		fmt.Fprintf(w, "export %s=%q\n", k, m[k])
	}
	return w.Flush()
}

// -------------------- validation hooks ---------------------------------- //

type validator func(env map[string]string) (bool, error)

var validators = map[string]validator{
	"External": validateExternal,
}

func validateExternal(env map[string]string) (bool, error) {
	path := env["EXTERNAL_LOCALWEB_PATH"]
	url := env["EXTERNAL_LOCALWEB_URL"]
	if path == "" || url == "" {
		return false, fmt.Errorf("EXTERNAL_LOCALWEB_PATH or URL not set")
	}

	name := uuid.NewString() + ".ribscfg"
	full := filepath.Join(path, name)
	if err := os.WriteFile(full, []byte("ribscfg connectivity check\n"), 0o644); err != nil {
		return false, err
	}
	defer os.Remove(full)

	resp, err := http.Get(strings.TrimSuffix(url, "/") + "/" + name)
	if err != nil {
		return false, err
	}
	defer resp.Body.Close()
	return resp.StatusCode >= 200 && resp.StatusCode < 300, nil
}

// ---------------------- wizard helpers ---------------------------------- //

func ensureDefaults(keys []groupedEnvKey, env map[string]string) {
	for _, k := range keys {
		if env[k.Var] == "" && k.DefaultValue != "" {
			env[k.Var] = k.DefaultValue
		}
	}
}

func menu(keys []groupedEnvKey) (string, error) {
	secMap := map[string]struct{}{}
	for _, k := range keys {
		if k.Advanced {
			continue
		}
		secMap[k.Section] = struct{}{}
	}
	sections := make([]string, 0, len(secMap)+3)
	for s := range secMap {
		sections = append(sections, s)
	}
	sort.Strings(sections)
	sections = append([]string{"Save & Exit", "Exit without saving"}, sections...)
	sections = append(sections, "Advanced ✦")

	opts := make([]huh.Option[string], len(sections))
	for i, s := range sections {
		opts[i] = huh.NewOption(s, s)
	}

	var sel string
	form := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().Title("Select configuration section").Options(opts...).Value(&sel),
		),
	)
	if err := form.Run(); err != nil {
		return "", err
	}
	return sel, nil
}

func editSection(section string, keys []groupedEnvKey, env map[string]string, editAdvanced bool) error {
	type binding struct {
		key   string
		value *string
	}
	bindings := []binding{}
	fields := []huh.Field{}

	home, _ := os.UserHomeDir()
	walletPath := filepath.Join(home, ".ribswallet")

	// Special handling for CIDGRAVITY_API_TOKEN: run before the form, skip adding to fields
	if section == "CIDGravity" && !editAdvanced {
		for _, k := range keys {
			if k.Section == section && k.Var == "CIDGRAVITY_API_TOKEN" && (k.Advanced == editAdvanced) {
				val := env[k.Var]
				newVal, err := handleCIDGravityTokenInput(walletPath, val)
				if err != nil {
					return err
				}
				env[k.Var] = newVal
				break
			}
		}
	}

	for _, k := range keys {
		if k.Section != section || (k.Advanced != editAdvanced) {
			continue
		}
		if k.Var == "CIDGRAVITY_API_TOKEN" && section == "CIDGravity" && !editAdvanced {
			// already handled above
			continue
		}
		val := env[k.Var] // local copy bound to input
		v := k            // copy
		bindings = append(bindings, binding{key: v.Var, value: &val})

		// Add envComment as Description if present
		comment := envComment(v.Var)
		input := huh.NewInput().Title(v.Var).Value(&val).Placeholder(v.DefaultValue)
		if comment != "" {
			input = input.Description(comment)
		}
		fields = append(fields, input)
	}

	if len(fields) == 0 {
		return nil
	}
	if err := huh.NewForm(huh.NewGroup(fields...)).Run(); err != nil {
		return err
	}
	// commit changes
	for _, b := range bindings {
		env[b.key] = *b.value
	}
	return nil
}

func confirm(title string, def bool) (bool, error) {
	yes := def
	err := huh.NewForm(
		huh.NewGroup(
			huh.NewConfirm().Title(title).Affirmative("Yes").Negative("No").Value(&yes),
		),
	).Run()
	return yes, err
}

func runValidator(section string, env map[string]string) (bool, error) {
	v, ok := validators[section]
	if !ok {
		return true, nil
	}
	do, err := confirm("Verify?", true)
	if err != nil || !do {
		return true, err
	}
	okRes, err := v(env)
	if err != nil {
		fmt.Printf("Validation error: %v\n", err)
		return false, nil
	}
	if okRes {
		fmt.Println("✅ Validation succeeded.")
		return true, nil
	}
	fmt.Println("❌ Validation failed.")
	return false, nil
}

func initialSetupWizard(envPath string, keys []groupedEnvKey) error {
	env := map[string]string{}

	// 1. Set CIDGravity API token
	for _, k := range keys {
		if k.Var == "CIDGRAVITY_API_TOKEN" {
			home, _ := os.UserHomeDir()
			walletPath := filepath.Join(home, ".ribswallet")
			val, err := handleCIDGravityTokenInput(walletPath, env[k.Var])
			if err != nil {
				return err
			}
			env[k.Var] = val
			break
		}
	}

	// 2. RIBS_DATA
	for _, k := range keys {
		if k.Section == "RIBS" && k.Var == "RIBS_DATA" {
			val := k.DefaultValue
			comment := envComment(k.Var)
			field := huh.NewInput().
				Title(k.Var).
				Value(&val).
				Placeholder(k.DefaultValue)
			if comment != "" {
				field = field.Description(comment)
			}
			if err := huh.NewForm(huh.NewGroup(field)).Run(); err != nil {
				return err
			}
			env[k.Var] = val
		}
	}

	// 2. Deal Config
	for _, k := range keys {
		if k.Section == "Deals" {
			val := k.DefaultValue
			comment := envComment(k.Var)
			field := huh.NewInput().
				Title(k.Var).
				Value(&val).
				Placeholder(k.DefaultValue)
			if comment != "" {
				field = field.Description(comment)
			}
			if err := huh.NewForm(huh.NewGroup(field)).Run(); err != nil {
				return err
			}
			env[k.Var] = val
		}
	}

	// 3. External config: s3/localweb
	var extType string
	extOpts := []huh.Option[string]{
		huh.NewOption("LocalWeb", "localweb"),
		huh.NewOption("S3", "s3"),
	}
	if err := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().Title("External config type").Options(extOpts...).Value(&extType),
		),
	).Run(); err != nil {
		return err
	}

	switch extType {
	case "s3":
		for _, k := range keys {
			if k.Section == "S3" {
				val := k.DefaultValue
				field := huh.NewInput().Title(k.Var).Value(&val).Placeholder(k.DefaultValue)
				if err := huh.NewForm(huh.NewGroup(field)).Run(); err != nil {
					return err
				}
				env[k.Var] = val
			}
		}
	case "localweb":
		for _, k := range keys {
			if k.Section == "External" {
				val := k.DefaultValue
				field := huh.NewInput().Title(k.Var).Value(&val).Placeholder(k.DefaultValue)
				if err := huh.NewForm(huh.NewGroup(field)).Run(); err != nil {
					return err
				}
				env[k.Var] = val
			}
		}
	}

	// Save config
	if err := saveEnv(envPath, env, envComment); err != nil {
		return err
	}
	fmt.Printf("Initial configuration saved to %s\n", envPath)
	return nil
}

func wizard(envPath string) error {
	keys, err := collectKeys()
	if err != nil {
		return err
	}
	env, err := loadEnv(envPath)
	if err != nil {
		return err
	}
	ensureDefaults(keys, env)

	for {
		sel, err := menu(keys)
		if err != nil {
			return err
		}
		switch sel {
		case "Save & Exit":
			if err := saveEnv(envPath, env, envComment); err != nil {
				return err
			}
			fmt.Printf("Configuration saved to %s\n", envPath)
			return nil
		case "Exit without saving":
			fmt.Println("Exiting without saving changes.")
			return nil
		case "Advanced ✦":
			// Edit all advanced keys, grouped by section
			sections := map[string]struct{}{}
			for _, k := range keys {
				if k.Advanced {
					sections[k.Section] = struct{}{}
				}
			}
			for section := range sections {
				if err := editSection(section, keys, env, true); err != nil {
					return err
				}
			}
			// Also handle any advanced keys not in a section
			if err := editSection("Advanced", keys, env, true); err != nil {
				return err
			}
		default:
			for {
				if err := editSection(sel, keys, env, false); err != nil {
					return err
				}
				verified, err := runValidator(sel, env)
				if err != nil {
					return err
				}
				if verified {
					break
				}
			}
		}
	}
}

// ---------------------- CLI helpers ------------------------------------- //

func cmdGet(envPath, key string) error {
	env, err := loadEnv(envPath)
	if err != nil {
		return err
	}
	if v, ok := env[key]; ok {
		fmt.Println(v)
		return nil
	}
	return fmt.Errorf("key %s not found", key)
}

func cmdSet(envPath, key, val string) error {
	env, err := loadEnv(envPath)
	if err != nil {
		return err
	}
	env[key] = val
	return saveEnv(envPath, env, envComment)
}

// --------------------------- main --------------------------------------- //

func envComment(key string) string {
	switch key {
	case "CIDGRAVITY_API_TOKEN":
		// Try to open/create wallet in the default location
		home, err := os.UserHomeDir()
		var walletAddr string
		if err == nil {
			walletPath := filepath.Join(home, ".ribswallet")
			_, addr, err := rbdeal.OpenOrCreateWallet(walletPath)
			if err == nil {
				walletAddr = addr.String()
			}
		}
		if walletAddr == "" {
			walletAddr = "<your-wallet-address>"
		}
		return fmt.Sprintf(`To get your API token:
1. Sign up at https://app.cidgravity.com
2. Go to https://app.cidgravity.com/wizard
3. Input %s as the wallet address
  NOTE: The address MUST exist on the Filecoin network. The easiest
    way to ensure that is to send a small amount of FIL to that address.
4. Click "Next"
5. Paste the challenge (hex or the whole command) into the prompt below
6. Paste the signed challenge back into the CIDGravity wizard
7. Click "Submit"
8. Copy the API token and paste it into the prompt below
`, walletAddr)
	case "RIBS_DEAL_DURATION":
		return "The duration of the deal in days"
	case "RIBS_DEAL_REMOVE_UNSEALED":
		return "Whether Storage Providers should remove hot-retrieval copy (true/false)"
	case "RIBS_DEAL_SKIP_IPNI_ANNOUNCE":
		return "Whether to ask Storage Providers to skip IPNI announcements (true/false) - note this doesn't stop others from retrieving the data if they have the CID"
	case "RIBS_DEAL_START_TIME":
		return "Time SPs have to handle the deal (Hours)"
	case "RIBS_DATA":
		return "The path to the RIBS data directory"
	}
	return ""
}

func handleCIDGravityTokenInput(walletPath, currentValue string) (string, error) {
	for {
		val := currentValue
		field := huh.NewInput().
			Title("CIDGravity API Token").
			Value(&val).
			Description(envComment("CIDGRAVITY_API_TOKEN"))
		if err := huh.NewForm(huh.NewGroup(field)).Run(); err != nil {
			return "", err
		}
		val = strings.TrimSpace(val)
		switch {
		case cidgApiKeyRe.MatchString(val):
			return val, nil
		case cidgHexChallengeRe.MatchString(val) || cidgLotusSignRe.MatchString(val):
			sig, err := signChallengeWithWallet(walletPath, val)
			if err != nil {
				fmt.Printf("❌ Signing failed: %s\n", err)
			} else {
				fmt.Printf("Signature (hex):\n%s\n", color.GreenString("%s", sig))
				fmt.Println("Paste this signature into the CIDGravity wizard, then paste the API token here.")
			}
			// Loop again for API key input
		default:
			fmt.Println("Input does not look like a valid API key or challenge. Please try again.")
		}
	}
}

// Signs a challenge with the wallet at the given path, returns hex signature
func signChallengeWithWallet(walletPath string, challenge string) (string, error) {
	wallet, addr, err := rbdeal.OpenOrCreateWallet(walletPath)
	if err != nil {
		return "", err
	}
	var msg []byte
	// If challenge is a "lotus wallet sign ..." command, extract the hex part
	if strings.HasPrefix(challenge, "lotus wallet sign ") {
		parts := strings.Fields(challenge)
		if len(parts) < 5 {
			return "", fmt.Errorf("invalid sign command")
		}
		challenge = parts[len(parts)-1]
	}

	fmt.Printf("Signing challenge: %s with wallet %s\n", challenge, addr.String())
	msg, err = hex.DecodeString(challenge)
	if err != nil {
		return "", fmt.Errorf("invalid hex challenge: %w", err)
	}
	sig, err := wallet.WalletSign(context.TODO(), addr, msg, api.MsgMeta{Type: api.MTUnknown})
	if err != nil {
		return "", fmt.Errorf("signing failed: %w", err)
	}
	sigBytes := append([]byte{byte(sig.Type)}, sig.Data...)

	return hex.EncodeToString(sigBytes), nil
}

func main() {
	var envFile string
	flag.StringVar(&envFile, "f", defaultEnvFile, "path to environment file")
	flag.Parse()

	abs, _ := filepath.Abs(envFile)

	switch flag.NArg() {
	case 0:
		_, err := os.Stat(abs)
		keys, _ := collectKeys()
		if errors.Is(err, os.ErrNotExist) {
			// Initial setup wizard
			if err := initialSetupWizard(abs, keys); err != nil {
				log.Fatalf("initial setup: %v", err)
			}
		} else {
			if err := wizard(abs); err != nil {
				log.Fatalf("wizard: %v", err)
			}
		}
	case 1: // get KEY
		if err := cmdGet(abs, flag.Arg(0)); err != nil {
			log.Fatal(err)
		}
	case 2: // set KEY VAL
		if err := cmdSet(abs, flag.Arg(0), flag.Arg(1)); err != nil {
			log.Fatal(err)
		}
	default:
		fmt.Fprintln(os.Stderr, "Usage: ribscfg [options]            # interactive wizard")
		fmt.Fprintln(os.Stderr, "       ribscfg get KEY              # print value")
		fmt.Fprintln(os.Stderr, "       ribscfg set KEY VAL          # non‑interactive update")
		flag.PrintDefaults()
		os.Exit(1)
	}
}
